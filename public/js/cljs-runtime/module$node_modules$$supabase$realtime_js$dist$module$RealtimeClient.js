shadow$provide.module$node_modules$$supabase$realtime_js$dist$module$RealtimeClient = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return RealtimeClient;
  }}});
  global = require("module$node_modules$$supabase$realtime_js$dist$module$WebSocket");
  var require$_DOT__SLASH_lib_SLASH_constants = require("module$node_modules$$supabase$realtime_js$dist$module$lib$constants");
  module = require("module$node_modules$$supabase$realtime_js$dist$module$lib$serializer");
  exports = require("module$node_modules$$supabase$realtime_js$dist$module$lib$timer");
  var require$_DOT__SLASH_lib_SLASH_transformers = require("module$node_modules$$supabase$realtime_js$dist$module$lib$transformers"), require$_DOT__SLASH_RealtimeChannel = require("module$node_modules$$supabase$realtime_js$dist$module$RealtimeChannel"), default$$require$_DOT__SLASH_lib_SLASH_serializer = require.esmDefault(module), default$$require$_DOT__SLASH_lib_SLASH_timer = require.esmDefault(exports), default$$require$_DOT__SLASH_WebSocket = require.esmDefault(global), default$$require$_DOT__SLASH_RealtimeChannel = 
  require.esmDefault(require$_DOT__SLASH_RealtimeChannel);
  const noop = () => {
  };
  class RealtimeClient {
    constructor(endPoint, options) {
      var _a;
      this.apiKey = this.accessTokenValue = null;
      this.channels = [];
      this.httpEndpoint = this.endPoint = "";
      this.headers = require$_DOT__SLASH_lib_SLASH_constants.DEFAULT_HEADERS;
      this.params = {};
      this.timeout = require$_DOT__SLASH_lib_SLASH_constants.DEFAULT_TIMEOUT;
      this.heartbeatIntervalMs = 25000;
      this.heartbeatTimer = void 0;
      this.pendingHeartbeatRef = null;
      this.heartbeatCallback = noop;
      this.ref = 0;
      this.logger = noop;
      this.conn = null;
      this.sendBuffer = [];
      this.serializer = new default$$require$_DOT__SLASH_lib_SLASH_serializer.default();
      this.stateChangeCallbacks = {open:[], close:[], error:[], message:[]};
      this.accessToken = null;
      this._resolveFetch = customFetch => {
        let _fetch;
        _fetch = customFetch ? customFetch : "undefined" === typeof fetch ? (...args) => require.dynamic("module$node_modules$$supabase$node_fetch$browser").then(({default:fetch}) => fetch(...args)) : fetch;
        return (...args) => _fetch(...args);
      };
      this.endPoint = `${endPoint}/${require$_DOT__SLASH_lib_SLASH_constants.TRANSPORTS.websocket}`;
      this.httpEndpoint = (0,require$_DOT__SLASH_lib_SLASH_transformers.httpEndpointURL)(endPoint);
      this.transport = (null === options || void 0 === options ? 0 : options.transport) ? options.transport : null;
      if (null === options || void 0 === options ? 0 : options.params) {
        this.params = options.params;
      }
      if (null === options || void 0 === options ? 0 : options.headers) {
        this.headers = Object.assign(Object.assign({}, this.headers), options.headers);
      }
      if (null === options || void 0 === options ? 0 : options.timeout) {
        this.timeout = options.timeout;
      }
      if (null === options || void 0 === options ? 0 : options.logger) {
        this.logger = options.logger;
      }
      if ((null === options || void 0 === options ? 0 : options.logLevel) || (null === options || void 0 === options ? 0 : options.log_level)) {
        this.logLevel = options.logLevel || options.log_level, this.params = Object.assign(Object.assign({}, this.params), {log_level:this.logLevel});
      }
      if (null === options || void 0 === options ? 0 : options.heartbeatIntervalMs) {
        this.heartbeatIntervalMs = options.heartbeatIntervalMs;
      }
      if (endPoint = null === (_a = null === options || void 0 === options ? void 0 : options.params) || void 0 === _a ? void 0 : _a.apikey) {
        this.apiKey = this.accessTokenValue = endPoint;
      }
      this.reconnectAfterMs = (null === options || void 0 === options ? 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => [1000, 2000, 5000, 10000][tries - 1] || 10000;
      this.encode = (null === options || void 0 === options ? 0 : options.encode) ? options.encode : (payload, callback) => callback(JSON.stringify(payload));
      this.decode = (null === options || void 0 === options ? 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);
      this.reconnectTimer = new default$$require$_DOT__SLASH_lib_SLASH_timer.default(async() => {
        this.disconnect();
        this.connect();
      }, this.reconnectAfterMs);
      this.fetch = this._resolveFetch(null === options || void 0 === options ? void 0 : options.fetch);
      if (null === options || void 0 === options ? 0 : options.worker) {
        if ("undefined" !== typeof window && !window.Worker) {
          throw Error("Web Worker is not supported");
        }
        this.worker = (null === options || void 0 === options ? void 0 : options.worker) || !1;
        this.workerUrl = null === options || void 0 === options ? void 0 : options.workerUrl;
      }
      this.accessToken = (null === options || void 0 === options ? void 0 : options.accessToken) || null;
    }
    connect() {
      this.conn || (this.transport || (this.transport = default$$require$_DOT__SLASH_WebSocket.default), this.transport ? (this.conn = "undefined" !== typeof window && this.transport === window.WebSocket ? new this.transport(this.endpointURL()) : new this.transport(this.endpointURL(), void 0, {headers:this.headers}), this.setupConnection()) : this.conn = new WSWebSocketDummy(this.endpointURL(), void 0, {close:() => {
        this.conn = null;
      }}));
    }
    endpointURL() {
      return this._appendParams(this.endPoint, Object.assign({}, this.params, {vsn:require$_DOT__SLASH_lib_SLASH_constants.VSN}));
    }
    disconnect(code, reason) {
      this.conn && (this.conn.onclose = function() {
      }, code ? this.conn.close(code, null !== reason && void 0 !== reason ? reason : "") : this.conn.close(), this.conn = null, this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.reconnectTimer.reset(), this.channels.forEach(channel => channel.teardown()));
    }
    getChannels() {
      return this.channels;
    }
    async removeChannel(channel) {
      const status = await channel.unsubscribe();
      this.channels = this.channels.filter(c => c._joinRef !== channel._joinRef);
      0 === this.channels.length && this.disconnect();
      return status;
    }
    async removeAllChannels() {
      const values_1 = await Promise.all(this.channels.map(channel => channel.unsubscribe()));
      this.channels = [];
      this.disconnect();
      return values_1;
    }
    log(kind, msg, data) {
      this.logger(kind, msg, data);
    }
    connectionState() {
      switch(this.conn && this.conn.readyState) {
        case require$_DOT__SLASH_lib_SLASH_constants.SOCKET_STATES.connecting:
          return require$_DOT__SLASH_lib_SLASH_constants.CONNECTION_STATE.Connecting;
        case require$_DOT__SLASH_lib_SLASH_constants.SOCKET_STATES.open:
          return require$_DOT__SLASH_lib_SLASH_constants.CONNECTION_STATE.Open;
        case require$_DOT__SLASH_lib_SLASH_constants.SOCKET_STATES.closing:
          return require$_DOT__SLASH_lib_SLASH_constants.CONNECTION_STATE.Closing;
        default:
          return require$_DOT__SLASH_lib_SLASH_constants.CONNECTION_STATE.Closed;
      }
    }
    isConnected() {
      return this.connectionState() === require$_DOT__SLASH_lib_SLASH_constants.CONNECTION_STATE.Open;
    }
    channel(topic, params = {config:{}}) {
      const realtimeTopic = `realtime:${topic}`, exists = this.getChannels().find(c => c.topic === realtimeTopic);
      if (exists) {
        return exists;
      }
      topic = new default$$require$_DOT__SLASH_RealtimeChannel.default(`realtime:${topic}`, params, this);
      this.channels.push(topic);
      return topic;
    }
    push(data) {
      const {topic, event, payload, ref} = data, callback = () => {
        this.encode(data, result => {
          var _a;
          null === (_a = this.conn) || void 0 === _a || _a.send(result);
        });
      };
      this.log("push", `${topic} ${event} (${ref})`, payload);
      this.isConnected() ? callback() : this.sendBuffer.push(callback);
    }
    async setAuth(token = null) {
      let tokenToSend = token || this.accessToken && await this.accessToken() || this.accessTokenValue;
      this.accessTokenValue != tokenToSend && (this.accessTokenValue = tokenToSend, this.channels.forEach(channel => {
        tokenToSend && channel.updateJoinPayload({access_token:tokenToSend, version:this.headers && this.headers["X-Client-Info"]});
        channel.joinedOnce && channel._isJoined() && channel._push(require$_DOT__SLASH_lib_SLASH_constants.CHANNEL_EVENTS.access_token, {access_token:tokenToSend});
      }));
    }
    async sendHeartbeat() {
      var _a;
      this.isConnected() ? this.pendingHeartbeatRef ? (this.pendingHeartbeatRef = null, this.log("transport", "heartbeat timeout. Attempting to re-establish connection"), this.heartbeatCallback("timeout"), null === (_a = this.conn) || void 0 === _a || _a.close(require$_DOT__SLASH_lib_SLASH_constants.WS_CLOSE_NORMAL, "hearbeat timeout")) : (this.pendingHeartbeatRef = this._makeRef(), this.push({topic:"phoenix", event:"heartbeat", payload:{}, ref:this.pendingHeartbeatRef}), this.heartbeatCallback("sent"), 
      await this.setAuth()) : this.heartbeatCallback("disconnected");
    }
    onHeartbeat(callback) {
      this.heartbeatCallback = callback;
    }
    flushSendBuffer() {
      this.isConnected() && 0 < this.sendBuffer.length && (this.sendBuffer.forEach(callback => callback()), this.sendBuffer = []);
    }
    _makeRef() {
      let newRef = this.ref + 1;
      this.ref = newRef === this.ref ? 0 : newRef;
      return this.ref.toString();
    }
    _leaveOpenTopic(topic) {
      let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));
      dupChannel && (this.log("transport", `leaving duplicate topic "${topic}"`), dupChannel.unsubscribe());
    }
    _remove(channel) {
      this.channels = this.channels.filter(c => c.topic !== channel.topic);
    }
    setupConnection() {
      this.conn && (this.conn.binaryType = "arraybuffer", this.conn.onopen = () => this._onConnOpen(), this.conn.onerror = error => this._onConnError(error), this.conn.onmessage = event => this._onConnMessage(event), this.conn.onclose = event => this._onConnClose(event));
    }
    _onConnMessage(rawMessage) {
      this.decode(rawMessage.data, msg => {
        let {topic, event, payload, ref} = msg;
        "phoenix" === topic && "phx_reply" === event && this.heartbeatCallback("ok" == msg.payload.status ? "ok" : "error");
        ref && ref === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null);
        this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        Array.from(this.channels).filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));
        this.stateChangeCallbacks.message.forEach(callback => callback(msg));
      });
    }
    _onConnOpen() {
      this.log("transport", `connected to ${this.endpointURL()}`);
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      if (this.worker) {
        this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker");
        const objectUrl = this._workerObjectUrl(this.workerUrl);
        this.workerRef = new Worker(objectUrl);
        this.workerRef.onerror = error => {
          this.log("worker", "worker error", error.message);
          this.workerRef.terminate();
        };
        this.workerRef.onmessage = event => {
          "keepAlive" === event.data.event && this.sendHeartbeat();
        };
        this.workerRef.postMessage({event:"start", interval:this.heartbeatIntervalMs});
      } else {
        this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
      }
      this.stateChangeCallbacks.open.forEach(callback => callback());
    }
    _onConnClose(event) {
      this.log("transport", "close", event);
      this._triggerChanError();
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.reconnectTimer.scheduleTimeout();
      this.stateChangeCallbacks.close.forEach(callback => callback(event));
    }
    _onConnError(error) {
      this.log("transport", error.message);
      this._triggerChanError();
      this.stateChangeCallbacks.error.forEach(callback => callback(error));
    }
    _triggerChanError() {
      this.channels.forEach(channel => channel._trigger(require$_DOT__SLASH_lib_SLASH_constants.CHANNEL_EVENTS.error));
    }
    _appendParams(url, params) {
      if (0 === Object.keys(params).length) {
        return url;
      }
      const prefix = url.match(/\?/) ? "\x26" : "?";
      params = new URLSearchParams(params);
      return `${url}${prefix}${params}`;
    }
    _workerObjectUrl(url) {
      url || (url = new Blob(['\n  addEventListener("message", (e) \x3d\x3e {\n    if (e.data.event \x3d\x3d\x3d "start") {\n      setInterval(() \x3d\x3e postMessage({ event: "keepAlive" }), e.data.interval);\n    }\n  });'], {type:"application/javascript"}), url = URL.createObjectURL(url));
      return url;
    }
  }
  class WSWebSocketDummy {
    constructor(address, _protocols, options) {
      this.binaryType = "arraybuffer";
      this.onclose = () => {
      };
      this.onerror = () => {
      };
      this.onmessage = () => {
      };
      this.onopen = () => {
      };
      this.readyState = require$_DOT__SLASH_lib_SLASH_constants.SOCKET_STATES.connecting;
      this.send = () => {
      };
      this.url = null;
      this.url = address;
      this.close = options.close;
    }
  }
};

//# sourceMappingURL=module$node_modules$$supabase$realtime_js$dist$module$RealtimeClient.js.map
