shadow$provide.module$node_modules$$supabase$realtime_js$dist$module$lib$transformers = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, PostgresTypes:{enumerable:!0, get:function() {
    return PostgresTypes;
  }}, convertCell:{enumerable:!0, get:function() {
    return convertCell;
  }}, convertChangeData:{enumerable:!0, get:function() {
    return convertChangeData;
  }}, convertColumn:{enumerable:!0, get:function() {
    return convertColumn;
  }}, httpEndpointURL:{enumerable:!0, get:function() {
    return httpEndpointURL;
  }}, toArray:{enumerable:!0, get:function() {
    return toArray;
  }}, toBoolean:{enumerable:!0, get:function() {
    return toBoolean;
  }}, toJson:{enumerable:!0, get:function() {
    return toJson;
  }}, toNumber:{enumerable:!0, get:function() {
    return toNumber;
  }}, toTimestampString:{enumerable:!0, get:function() {
    return toTimestampString;
  }}});
  var PostgresTypes;
  (function(PostgresTypes) {
    PostgresTypes.abstime = "abstime";
    PostgresTypes.bool = "bool";
    PostgresTypes.date = "date";
    PostgresTypes.daterange = "daterange";
    PostgresTypes.float4 = "float4";
    PostgresTypes.float8 = "float8";
    PostgresTypes.int2 = "int2";
    PostgresTypes.int4 = "int4";
    PostgresTypes.int4range = "int4range";
    PostgresTypes.int8 = "int8";
    PostgresTypes.int8range = "int8range";
    PostgresTypes.json = "json";
    PostgresTypes.jsonb = "jsonb";
    PostgresTypes.money = "money";
    PostgresTypes.numeric = "numeric";
    PostgresTypes.oid = "oid";
    PostgresTypes.reltime = "reltime";
    PostgresTypes.text = "text";
    PostgresTypes.time = "time";
    PostgresTypes.timestamp = "timestamp";
    PostgresTypes.timestamptz = "timestamptz";
    PostgresTypes.timetz = "timetz";
    PostgresTypes.tsrange = "tsrange";
    PostgresTypes.tstzrange = "tstzrange";
  })(PostgresTypes || (PostgresTypes = {}));
  const convertChangeData = (columns, record, options = {}) => {
    var _a;
    const skipTypes = null !== (_a = options.skipTypes) && void 0 !== _a ? _a : [];
    return Object.keys(record).reduce((acc, rec_key) => {
      acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
      return acc;
    }, {});
  }, convertColumn = (columnName, columns, record, skipTypes) => {
    columns = columns.find(x => x.name === columnName);
    columns = null === columns || void 0 === columns ? void 0 : columns.type;
    record = record[columnName];
    return columns && !skipTypes.includes(columns) ? convertCell(columns, record) : record;
  }, convertCell = (type, value) => {
    if ("_" === type.charAt(0)) {
      return type = type.slice(1, type.length), toArray(value, type);
    }
    switch(type) {
      case PostgresTypes.bool:
        return toBoolean(value);
      case PostgresTypes.float4:
      case PostgresTypes.float8:
      case PostgresTypes.int2:
      case PostgresTypes.int4:
      case PostgresTypes.int8:
      case PostgresTypes.numeric:
      case PostgresTypes.oid:
        return toNumber(value);
      case PostgresTypes.json:
      case PostgresTypes.jsonb:
        return toJson(value);
      case PostgresTypes.timestamp:
        return toTimestampString(value);
      case PostgresTypes.abstime:
      case PostgresTypes.date:
      case PostgresTypes.daterange:
      case PostgresTypes.int4range:
      case PostgresTypes.int8range:
      case PostgresTypes.money:
      case PostgresTypes.reltime:
      case PostgresTypes.text:
      case PostgresTypes.time:
      case PostgresTypes.timestamptz:
      case PostgresTypes.timetz:
      case PostgresTypes.tsrange:
      case PostgresTypes.tstzrange:
        return value;
      default:
        return value;
    }
  }, toBoolean = value => {
    switch(value) {
      case "t":
        return !0;
      case "f":
        return !1;
      default:
        return value;
    }
  }, toNumber = value => {
    if ("string" === typeof value) {
      const parsedValue = parseFloat(value);
      if (!Number.isNaN(parsedValue)) {
        return parsedValue;
      }
    }
    return value;
  }, toJson = value => {
    if ("string" === typeof value) {
      try {
        return JSON.parse(value);
      } catch (error) {
        console.log(`JSON parse error: ${error}`);
      }
    }
    return value;
  }, toArray = (value, type) => {
    if ("string" !== typeof value) {
      return value;
    }
    const lastIdx = value.length - 1, closeBrace = value[lastIdx];
    if ("{" === value[0] && "}" === closeBrace) {
      let arr;
      value = value.slice(1, lastIdx);
      try {
        arr = JSON.parse("[" + value + "]");
      } catch (_) {
        arr = value ? value.split(",") : [];
      }
      return arr.map(val => convertCell(type, val));
    }
    return value;
  }, toTimestampString = value => "string" === typeof value ? value.replace(" ", "T") : value, httpEndpointURL = socketUrl => {
    socketUrl = socketUrl.replace(/^ws/i, "http");
    socketUrl = socketUrl.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, "");
    return socketUrl.replace(/\/+$/, "");
  };
};

//# sourceMappingURL=module$node_modules$$supabase$realtime_js$dist$module$lib$transformers.js.map
