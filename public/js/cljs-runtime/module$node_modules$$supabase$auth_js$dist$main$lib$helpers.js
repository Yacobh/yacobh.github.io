shadow$provide.module$node_modules$$supabase$auth_js$dist$main$lib$helpers = function(global, require, module, exports) {
  function dec2hex(dec) {
    return ("0" + dec.toString(16)).substr(-2);
  }
  function generatePKCEVerifier() {
    var array = new Uint32Array(56);
    if ("undefined" === typeof crypto) {
      array = "";
      for (let i = 0; 56 > i; i++) {
        array += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~".charAt(Math.floor(66 * Math.random()));
      }
      return array;
    }
    crypto.getRandomValues(array);
    return Array.from(array, dec2hex).join("");
  }
  async function sha256(randomString) {
    randomString = (new TextEncoder()).encode(randomString);
    randomString = await crypto.subtle.digest("SHA-256", randomString);
    randomString = new Uint8Array(randomString);
    return Array.from(randomString).map(c => String.fromCharCode(c)).join("");
  }
  async function generatePKCEChallenge(verifier) {
    if ("undefined" === typeof crypto || "undefined" === typeof crypto.subtle || "undefined" === typeof TextEncoder) {
      return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."), verifier;
    }
    verifier = await sha256(verifier);
    return btoa(verifier).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
  var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {enumerable:!0, get:function() {
        return m[k];
      }};
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    o[k2] = m[k];
  }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable:!0, value:v});
  } : function(o, v) {
    o["default"] = v;
  }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) {
      return mod;
    }
    var result = {};
    if (null != mod) {
      for (var k in mod) {
        "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      }
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getAlgorithm = exports.validateExp = exports.parseResponseAPIVersion = exports.getCodeChallengeAndMethod = exports.generatePKCEChallenge = exports.generatePKCEVerifier = exports.retryable = exports.sleep = exports.decodeJWT = exports.Deferred = exports.removeItemAsync = exports.getItemAsync = exports.setItemAsync = exports.looksLikeFetchResponse = exports.resolveFetch = exports.parseParametersFromURL = exports.supportsLocalStorage = exports.isBrowser = exports.uuid = exports.expiresAt = 
  void 0;
  const constants_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$constants"), errors_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$errors"), base64url_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$base64url");
  exports.expiresAt = function(expiresIn) {
    return Math.round(Date.now() / 1000) + expiresIn;
  };
  exports.uuid = function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r = 16 * Math.random() | 0;
      return ("x" == c ? r : r & 3 | 8).toString(16);
    });
  };
  exports.isBrowser = () => "undefined" !== typeof window && "undefined" !== typeof document;
  var JSCompiler_object_inline_tested_115 = !1, JSCompiler_object_inline_writable_116 = !1;
  exports.supportsLocalStorage = () => {
    if (!(0,exports.isBrowser)()) {
      return !1;
    }
    try {
      if ("object" !== typeof globalThis.localStorage) {
        return !1;
      }
    } catch (e) {
      return !1;
    }
    if (JSCompiler_object_inline_tested_115) {
      return JSCompiler_object_inline_writable_116;
    }
    const randomKey = `lswt-${Math.random()}${Math.random()}`;
    try {
      globalThis.localStorage.setItem(randomKey, randomKey), globalThis.localStorage.removeItem(randomKey), JSCompiler_object_inline_writable_116 = JSCompiler_object_inline_tested_115 = !0;
    } catch (e) {
      JSCompiler_object_inline_tested_115 = !0, JSCompiler_object_inline_writable_116 = !1;
    }
    return JSCompiler_object_inline_writable_116;
  };
  exports.parseParametersFromURL = function(href) {
    const result = {};
    href = new URL(href);
    if (href.hash && "#" === href.hash[0]) {
      try {
        (new URLSearchParams(href.hash.substring(1))).forEach((value, key) => {
          result[key] = value;
        });
      } catch (e) {
      }
    }
    href.searchParams.forEach((value, key) => {
      result[key] = value;
    });
    return result;
  };
  exports.resolveFetch = customFetch => {
    let _fetch;
    _fetch = customFetch ? customFetch : "undefined" === typeof fetch ? (...args) => Promise.resolve().then(() => __importStar(require("module$node_modules$$supabase$node_fetch$browser"))).then(({default:fetch}) => fetch(...args)) : fetch;
    return (...args) => _fetch(...args);
  };
  exports.looksLikeFetchResponse = maybeResponse => "object" === typeof maybeResponse && null !== maybeResponse && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && "function" === typeof maybeResponse.json;
  exports.setItemAsync = async(storage, key, data) => {
    await storage.setItem(key, JSON.stringify(data));
  };
  exports.getItemAsync = async(storage, key) => {
    storage = await storage.getItem(key);
    if (!storage) {
      return null;
    }
    try {
      return JSON.parse(storage);
    } catch (_a) {
      return storage;
    }
  };
  exports.removeItemAsync = async(storage, key) => {
    await storage.removeItem(key);
  };
  class Deferred {
    constructor() {
      this.promise = new Deferred.promiseConstructor((res, rej) => {
        this.resolve = res;
        this.reject = rej;
      });
    }
  }
  exports.Deferred = Deferred;
  Deferred.promiseConstructor = Promise;
  exports.decodeJWT = function(token) {
    token = token.split(".");
    if (3 !== token.length) {
      throw new errors_1.AuthInvalidJwtError("Invalid JWT structure");
    }
    for (let i = 0; i < token.length; i++) {
      if (!constants_1.BASE64URL_REGEX.test(token[i])) {
        throw new errors_1.AuthInvalidJwtError("JWT not in base64url format");
      }
    }
    return {header:JSON.parse((0,base64url_1.stringFromBase64URL)(token[0])), payload:JSON.parse((0,base64url_1.stringFromBase64URL)(token[1])), signature:(0,base64url_1.base64UrlToUint8Array)(token[2]), raw:{header:token[0], payload:token[1]}};
  };
  exports.sleep = async function(time) {
    return await new Promise(accept => {
      setTimeout(() => accept(null), time);
    });
  };
  exports.retryable = function(fn, isRetryable) {
    return new Promise((accept, reject) => {
      (async() => {
        for (let attempt = 0; Infinity > attempt; attempt++) {
          try {
            const result = await fn(attempt);
            if (!isRetryable(attempt, null, result)) {
              accept(result);
              break;
            }
          } catch (e) {
            if (!isRetryable(attempt, e)) {
              reject(e);
              break;
            }
          }
        }
      })();
    });
  };
  exports.generatePKCEVerifier = generatePKCEVerifier;
  exports.generatePKCEChallenge = generatePKCEChallenge;
  exports.getCodeChallengeAndMethod = async function(storage, storageKey, isPasswordRecovery = !1) {
    const codeVerifier = generatePKCEVerifier();
    let storedCodeVerifier = codeVerifier;
    isPasswordRecovery && (storedCodeVerifier += "/PASSWORD_RECOVERY");
    await (0,exports.setItemAsync)(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
    storage = await generatePKCEChallenge(codeVerifier);
    return [storage, codeVerifier === storage ? "plain" : "s256"];
  };
  const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
  exports.parseResponseAPIVersion = function(response) {
    response = response.headers.get(constants_1.API_VERSION_HEADER_NAME);
    if (!response || !response.match(API_VERSION_REGEX)) {
      return null;
    }
    try {
      return new Date(`${response}T00:00:00.0Z`);
    } catch (e) {
      return null;
    }
  };
  exports.validateExp = function(exp) {
    if (!exp) {
      throw Error("Missing exp claim");
    }
    const timeNow = Math.floor(Date.now() / 1000);
    if (exp <= timeNow) {
      throw Error("JWT has expired");
    }
  };
  exports.getAlgorithm = function(alg) {
    switch(alg) {
      case "RS256":
        return {name:"RSASSA-PKCS1-v1_5", hash:{name:"SHA-256"}};
      case "ES256":
        return {name:"ECDSA", namedCurve:"P-256", hash:{name:"SHA-256"}};
      default:
        throw Error("Invalid alg claim");
    }
  };
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$lib$helpers.js.map
