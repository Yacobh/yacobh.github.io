shadow$provide.module$node_modules$$supabase$auth_js$dist$main$lib$base64url = function(global, require, module, exports) {
  function byteToBase64URL(byte, state, emit) {
    if (null !== byte) {
      for (state.queue = state.queue << 8 | byte, state.queuedBits += 8; 6 <= state.queuedBits;) {
        emit(TO_BASE64URL[state.queue >> state.queuedBits - 6 & 63]), state.queuedBits -= 6;
      }
    } else if (0 < state.queuedBits) {
      for (state.queue <<= 6 - state.queuedBits, state.queuedBits = 6; 6 <= state.queuedBits;) {
        emit(TO_BASE64URL[state.queue >> state.queuedBits - 6 & 63]), state.queuedBits -= 6;
      }
    }
  }
  function byteFromBase64URL(charCode, state, emit) {
    const bits = FROM_BASE64URL[charCode];
    if (-1 < bits) {
      for (state.queue = state.queue << 6 | bits, state.queuedBits += 6; 8 <= state.queuedBits;) {
        emit(state.queue >> state.queuedBits - 8 & 255), state.queuedBits -= 8;
      }
    } else if (-2 !== bits) {
      throw Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`);
    }
  }
  function codepointToUTF8(codepoint, emit) {
    if (127 >= codepoint) {
      emit(codepoint);
    } else if (2047 >= codepoint) {
      emit(192 | codepoint >> 6), emit(128 | codepoint & 63);
    } else {
      if (65535 >= codepoint) {
        emit(224 | codepoint >> 12), emit(128 | codepoint >> 6 & 63), emit(128 | codepoint & 63);
      } else {
        if (1114111 >= codepoint) {
          emit(240 | codepoint >> 18), emit(128 | codepoint >> 12 & 63), emit(128 | codepoint >> 6 & 63), emit(128 | codepoint & 63);
        } else {
          throw Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);
        }
      }
    }
  }
  function stringToUTF8(str, emit) {
    for (let i = 0; i < str.length; i += 1) {
      var codepoint = str.charCodeAt(i);
      55295 < codepoint && 56319 >= codepoint && (codepoint = 1024 * (codepoint - 55296) & 65535, codepoint = (str.charCodeAt(i + 1) - 56320 & 65535 | codepoint) + 65536, i += 1);
      codepointToUTF8(codepoint, emit);
    }
  }
  function stringFromUTF8(byte, state, emit) {
    if (0 === state.utf8seq) {
      if (127 >= byte) {
        emit(byte);
      } else {
        for (emit = 1; 6 > emit; emit += 1) {
          if (0 === (byte >> 7 - emit & 1)) {
            state.utf8seq = emit;
            break;
          }
        }
        if (2 === state.utf8seq) {
          state.codepoint = byte & 31;
        } else if (3 === state.utf8seq) {
          state.codepoint = byte & 15;
        } else if (4 === state.utf8seq) {
          state.codepoint = byte & 7;
        } else {
          throw Error("Invalid UTF-8 sequence");
        }
        --state.utf8seq;
      }
    } else if (0 < state.utf8seq) {
      if (127 >= byte) {
        throw Error("Invalid UTF-8 sequence");
      }
      state.codepoint = state.codepoint << 6 | byte & 63;
      --state.utf8seq;
      0 === state.utf8seq && emit(state.codepoint);
    }
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.stringToUint8Array = exports.base64UrlToUint8Array = exports.stringFromUTF8 = exports.stringToUTF8 = exports.codepointToUTF8 = exports.stringFromBase64URL = exports.stringToBase64URL = exports.byteFromBase64URL = exports.byteToBase64URL = void 0;
  const TO_BASE64URL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""), IGNORE_BASE64URL = [" ", "\t", "\n", "\r", "\x3d"], FROM_BASE64URL = (() => {
    const charMap = Array(128);
    for (var i = 0; i < charMap.length; i += 1) {
      charMap[i] = -1;
    }
    for (i = 0; i < IGNORE_BASE64URL.length; i += 1) {
      charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;
    }
    for (i = 0; i < TO_BASE64URL.length; i += 1) {
      charMap[TO_BASE64URL[i].charCodeAt(0)] = i;
    }
    return charMap;
  })();
  exports.byteToBase64URL = byteToBase64URL;
  exports.byteFromBase64URL = byteFromBase64URL;
  exports.stringToBase64URL = function(str) {
    const base64 = [], emitter = char => {
      base64.push(char);
    }, state = {queue:0, queuedBits:0};
    stringToUTF8(str, byte => {
      byteToBase64URL(byte, state, emitter);
    });
    byteToBase64URL(null, state, emitter);
    return base64.join("");
  };
  exports.stringFromBase64URL = function(str) {
    const conv = [], utf8Emit = codepoint => {
      conv.push(String.fromCodePoint(codepoint));
    }, utf8State = {utf8seq:0, codepoint:0}, b64State = {queue:0, queuedBits:0}, byteEmit = byte => {
      stringFromUTF8(byte, utf8State, utf8Emit);
    };
    for (let i = 0; i < str.length; i += 1) {
      byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);
    }
    return conv.join("");
  };
  exports.codepointToUTF8 = codepointToUTF8;
  exports.stringToUTF8 = stringToUTF8;
  exports.stringFromUTF8 = stringFromUTF8;
  exports.base64UrlToUint8Array = function(str) {
    const result = [], state = {queue:0, queuedBits:0}, onByte = byte => {
      result.push(byte);
    };
    for (let i = 0; i < str.length; i += 1) {
      byteFromBase64URL(str.charCodeAt(i), state, onByte);
    }
    return new Uint8Array(result);
  };
  exports.stringToUint8Array = function(str) {
    const result = [];
    stringToUTF8(str, byte => result.push(byte));
    return new Uint8Array(result);
  };
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$lib$base64url.js.map
