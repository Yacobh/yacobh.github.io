shadow$provide.module$node_modules$$supabase$realtime_js$dist$module$lib$push = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return Push;
  }}});
  var require$_DOT__DOT__SLASH_lib_SLASH_constants = require("module$node_modules$$supabase$realtime_js$dist$module$lib$constants");
  class Push {
    constructor(channel, event, payload = {}, timeout = require$_DOT__DOT__SLASH_lib_SLASH_constants.DEFAULT_TIMEOUT) {
      this.channel = channel;
      this.event = event;
      this.payload = payload;
      this.timeout = timeout;
      this.sent = !1;
      this.timeoutTimer = void 0;
      this.ref = "";
      this.receivedResp = null;
      this.recHooks = [];
      this.refEvent = null;
    }
    resend(timeout) {
      this.timeout = timeout;
      this._cancelRefEvent();
      this.ref = "";
      this.receivedResp = this.refEvent = null;
      this.sent = !1;
      this.send();
    }
    send() {
      this._hasReceived("timeout") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({topic:this.channel.topic, event:this.event, payload:this.payload, ref:this.ref, join_ref:this.channel._joinRef()}));
    }
    updatePayload(payload) {
      this.payload = Object.assign(Object.assign({}, this.payload), payload);
    }
    receive(status, callback) {
      var _a;
      this._hasReceived(status) && callback(null === (_a = this.receivedResp) || void 0 === _a ? void 0 : _a.response);
      this.recHooks.push({status, callback});
      return this;
    }
    startTimeout() {
      this.timeoutTimer || (this.ref = this.channel.socket._makeRef(), this.refEvent = this.channel._replyEventName(this.ref), this.channel._on(this.refEvent, {}, payload => {
        this._cancelRefEvent();
        this._cancelTimeout();
        this.receivedResp = payload;
        this._matchReceive(payload);
      }), this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout));
    }
    trigger(status, response) {
      this.refEvent && this.channel._trigger(this.refEvent, {status, response});
    }
    destroy() {
      this._cancelRefEvent();
      this._cancelTimeout();
    }
    _cancelRefEvent() {
      this.refEvent && this.channel._off(this.refEvent, {});
    }
    _cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = void 0;
    }
    _matchReceive({status, response}) {
      this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response));
    }
    _hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
  }
};

//# sourceMappingURL=module$node_modules$$supabase$realtime_js$dist$module$lib$push.js.map
